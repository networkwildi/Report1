---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
# ########################################################################3


05. Report 3
Content
Resources 1
Questions 6
Introduction
Here we will study the open data about politicians in Zürich and see if we can find interesting patterns. The data comes to you in a relational database.


In this project, we will increase the complexity a bit. First the data is on four different tables, so there will be a lot more joins. Second we are not giving you .csv files but a functional SQLite database. Although we have seen how you can use your normal {dplyr} knowledge directly with databases, you will still have to write the code to connect to it and collect() the data you need at the right time.

The data
Under the Resources tab of this unit you will find a zip file with the following files:

## zh_politicians.db

This file is a SQLite database and contains data about elected politicians in Zürich over the years. Some columns like activity are in German but this won't affect your analysis. The different tables have information about:

The elected persons (name, gender, year of birth, year of death…)
The mandates people have been elected for
The addresses of the elected persons
The affiliations to political organisation
This is a relational database, so you will probably need to do a lot of JOINS between tables. Take the time to study the database structure, either directly with R using {DBI} and {dplyr} or first with the software we used in the course "DB Browser for SQLite".

Warning
This dataset is quite messy: consider this as a real-life example! Missing dates, misspelled names…

## Your goal is to do your best with what you were given and explain your thought process along the way. For example, if a politician seems to be 3 years old or 200 years old, filter him/her out before calculating the average age of politicians…

Before you start
## There is a technique that we did not cover in the course and that you will have to explore for this report. The idea is:

## What if I create a column with mutate() that put not one value in each cells, but a collection of values in each cell (vector or list)?

## There is a dataset, called starwars that comes pre-installed with {dplyr} that will show you that kind of table. Try the code below:

```{r}
library(dplyr)
starwars

library(dplyr)
starwars %>%
  select(name, species, films) %>%
  View()

library(dplyr)
starwars %>%
  pull(films) %>%
  head(3) # showing just the first result...

library(dplyr)
library(tidyr)
starwars %>%
  select(name, species, films) %>%
  unnest(films)



```  
  select(name, species, films) # Showing only a few columns for clarity
# A tibble: 87 x 3
   name               species films    
   <chr>              <chr>   <list>   
 1 Luke Skywalker     Human   <chr [5]>
 2 C-3PO              Droid   <chr [6]>

As you can see the cells in the column films do not contain "single value". Instead, they have vector of character. Row 1 has 5 items (probably meaning that "Luke Skywalker" was in 5 films), Row 2 has 6 items (probably meaning that "C-3PO" was in 6 films)…

You can get a better look at the content of the film column if you use View():

library(dplyr)
starwars %>%
  select(name, species, films) %>%
  View()
With View(), you will see at least the first items. For example the first row shows something like this:

c("Revenge of the Sith", "Return of the Jedi", "The Empire Strikes Back", "A New Hope", "The Force Awakens")
We can see that the cell contains a vector indeed. Another way to see the content could be to extract the column out of the tibble with our trusted pull() function.

library(dplyr)
starwars %>%
  pull(films) %>%
  head(3) # showing just the first result...
[[1]]
[1] "Revenge of the Sith"     "Return of the Jedi"      "The Empire Strikes Back"
[4] "A New Hope"              "The Force Awakens"      

[[2]]
[1] "Attack of the Clones"    "The Phantom Menace"      "Revenge of the Sith"    
[4] "Return of the Jedi"      "The Empire Strikes Back" "A New Hope"             

[[3]]
[1] "Attack of the Clones"    "The Phantom Menace"      "Revenge of the Sith"    
[4] "Return of the Jedi"      "The Empire Strikes Back" "A New Hope"             
[7] "The Force Awakens" 

Here again, looking at these double brackets ([[) we see that we are dealing with a list with each item being a vector of films.

# The list-columns, as they are called, are one of the most powerful features of the {tidyverse}: they kind of let you create "multi-dimensional" tibble. But this only become interesting if they let you "come back" to a normal "flat" tibble…which is what the unnest() function from {tidyr} is used for!

Let's say that I want to calculate the number of characters that have been in each movie. For that I need to be able to use group_by() on a per-film basis. How can I get a column that will contains only one film? unnest() to the rescue!

library(dplyr)
library(tidyr)
starwars %>%
  select(name, species, films) %>%
  unnest(films)
  
  
# A tibble: 173 x 3
   name           species films                  
   <chr>          <chr>   <chr>                  
 1 Luke Skywalker Human   Revenge of the Sith    
 2 Luke Skywalker Human   Return of the Jedi     
 3 Luke Skywalker Human   The Empire Strikes Back
 4 Luke Skywalker Human   A New Hope             
 5 Luke Skywalker Human   The Force Awakens      
 6 C-3PO          Droid   Attack of the Clones   
 7 C-3PO          Droid   The Phantom Menace     
 8 C-3PO          Droid   Revenge of the Sith    
 9 C-3PO          Droid   Return of the Jedi     
10 C-3PO          Droid   The Empire Strikes Back
# ... with 163 more rows

#########3##

Just like that we now have one film per row (with all the other values being repeated)! That is why our tibble went from 87 to 173 rows. And this tibble can be used to do calculation per film!

In this project, you will need this concept to work your way easily from items that only have start date and end date to something usable for analysis.

list-columns is a topic that we can only brush on in this course and I hope to cover them extensively in a more advanced program. But if you want to learn more about them now, I cannot recommend enough these two videos (in this order):

Garrett Grolemund - How to work with list columns
Jenny Bryan - Thinking inside the box
And one more hint
Do you remember map(), the function from the {purrr} package that we used to apply functions to each elements of a collection (i.e. list or vector)? Let's do a quick recap.

Most functions in R can accept collections and happily do their job on each item. If I use the ymd() function from {lubridate}, I can give it one date or two thousands dates and it will work.

However, some functions are not designed to work with collections and this can be annoying. For example, if I have a list of websites that I want to download, I cannot give a vector with lots of urls to the GET() function of the {httr} package. It will crash and say:

Hey, my url argument (which is GET() first argument) must be of length 1!

…which basically its way to say that it can only accept one url at a time.

## map() is a great workaround in these situation. map() takes a collection as its first argument and a function as its second argument. Then it applies the function to each element in the collection and wrap all the results in a new list that we can use for analysis.

So if we have three urls, we could do:

library(httr)
library(purrr)

urls <- c("www.google.com", "www.wikipedia.com", "www.extensionschool.ch")

map(urls, GET)
Note that we did not do:

map(GET(urls))
This is something that always confuse people when they discover map(). They will say:

But I put it in map()! It should work now!
   # ###############
But if you do it this way, R will first execute GET(urls) and crash even before it ever get the chance to run map(). That is why the collection and the function are given separately.

What does this mean if you want to use a function on two collections? For example, you want to use the function seq() which takes a start value (the argument is called from=) and an end value (the argument is called to=) and create a vector with all the value in between.

seq(1, 10)
[1]  1  2  3  4  5  6  7  8  9 10
We did not see seq() in the course, but we saw its cousin, the : operator (e.g. 1:10).

seq(), like GET(), doesn't work on collections. If I give a vector of three values for from= and a vector of three values for to=, I will not get three vectors with all the values in between.

seq(c(1,10,100), c(3, 13, 103))
Error in seq.default(c(1, 10, 100), c(3, 13, 103)) : 
  'from' must be of length 1
Can we use something like seq() with {purrr}? We sure can, with just one twist: map() only takes one collection. If your do:

map(c(1,10,100), c(3, 13, 103), seq)
map() will think that the second argument (i.e. c(3, 13, 103)) is the function you want to apply to the first argument… Needless to say that it will be terribly confused! But map2() is designed to take two arguments before getting a function, so this will work:

map2(c(1,10,100), c(3, 13, 103), seq)
[[1]]
[1] 1 2 3

[[2]]
[1] 10 11 12 13

[[3]]
[1] 100 101 102 103
So powerful! Now I see you coming with:

What if I have 3, 6 or 28 collections?

Realistically, it nearly never happens. Even map2() is rare. But if you want to venture into more collections, you can explore the pmap() function, which we won't cover here.

Why is map2() important if it is so niche? First I think understanding map2() helps you understanding map(). Second, you might want to use mutate and seq() with two columns from your tibble and get a result for each row in this project. Who knows, map2() could be handy if you ever found yourself in this situation…
#  ############################################################


###  Resources  zh_politicians.db.zip

#Exercises
## Part 1
The MANDATES table has information about when people where elected, when their mandate ended and on which assembly they sat.
Using a line plot, show how the number of people with an active mandate changed over the years. You will have one line per assembly.

You can see above what it will roughly look like. You can base your "active" years just on years, even if this creates some "dents" in the line (i.e. when looking only at active years, not precise dates, some mandates are double counted on election years since the old mandates end and the new mandates start).

Read zh_politicians.db

```{r}
library(DBI)
library(RSQLite)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(janitor)
library(tibble)
library(stringr)
library(shiny)


# 10. Replace SQL with dplyr
# zh_politicians.db 


politician_dbq <- dbConnect(RSQLite::SQLite(), "zh_politicians.db")
db_list_tables(politician_dbq)
# dbDisconnect(politician_dbq)                # use if disconnect

mandates <- tbl(politician_dbq, "MANDATES")      # FUNKTIONIERT
mandates_tbl <- as_tibble(mandates)
mandates_tbl <- mandates_tbl %>% 
mutate(as.numeric(MANDATE_START_DAY, MANDATE_START_MONTH, MANDATE_START_YEAR, MANDATE_END_DAY, MANDATE_END_MONTH, MANDATE_END_YEAR))


addresses <- tbl(politician_dbq, "ADDRESSES")
addresses_tbl <- as_tibble(addresses)
addresses_tbl <- addresses_tbl %>% 
 mutate(as.numeric(MANDATE_START_DAY, MANDATE_START_MONTH, MANDATE_START_YEAR, MANDATE_END_DAY, MANDATE_END_MONTH, MANDATE_END_YEAR))


affiliations <- tbl(politician_dbq, "AFFILIATIONS")
affiliations_tbl <- as_tibble(affiliations)
affiliations_tbl <- affiliations_tbl %>% 
mutate(as.numeric(AFFILIATION_START_DAY, AFFILIATION_START_MONTH, AFFILIATION_START_YEAR, AFFILIATION_END_MONTH, AFFILIATION_END_YEAR))

persons <- tbl(politician_dbq, "PERSONS")
persons_tbl <- as_tibble(persons)
 persons_tbl <- persons_tbl %>% 
  mutate(as.numeric(YEAR_OF_BIRTH,YEAR_OF_DEATH)) %>% 
  rename(PERSON_ID = ID)
    
  
  
# Funktioniert
mand_addr <- full_join(mandates_tbl,addresses_tbl, by = "PERSON_ID", copy = true) %>% 
clean_names()
mand_addr2 <- full_join(affiliations_tbl, persons_tbl, by = "PERSON_ID", copy = TRUE) %>% 
  clean_names()

# Funktioniert
mand_addr3 <- full_join(mand_addr, mand_addr2, by = "person_id", copy = TRUE)



#########################


# Funktioniert !!
age_try <- mand_addr3 %>% 
  select(assembly,mandate_start_year_x,mandate_end_year_x, year_of_birth, year_of_death) %>%  
    filter(year_of_birth != "", year_of_death != "") %>% 
      filter(year_of_birth != year_of_death) %>% 
        mutate(year_of_birth = as.numeric(year_of_birth)) %>% 
          mutate(year_of_death = as.numeric(year_of_death)) %>% 
            mutate(age = (year_of_death - year_of_birth)) %>% 
              filter(age >=20 & age <=70) %>%  
                group_by(assembly) %>% 
                  arrange(desc(mandate_start_year_x))
                      
  
filt_mandates <- age_try %>% 
  select(assembly, mandate_start_year_x,mandate_end_year_x)

man_count <- age_try %>% 
  count(assembly, mandate_start_year_x, mandate_end_year_x) %>% 
    mutate(count = n)
                  
#########################

# Funktioniert

ggplot(data=man_count, mapping = aes(x=mandate_end_year_x , y=count))+
  geom_line()+
  geom_point(size=4, aes(color=assembly))+
    labs(x="Mandates from 1800 - 2020", y="Count of assembly")
  
    #  Done

```


Line plot , one line per assembly

```{r}
# Line plot , one line per assembly




```

Part 2
Expand on the plot you just produced. This time you want to show a facet charts with one chart per assembly. In each chart, have one line for men and one line for women.

```{r}


library(DBI)
library(RSQLite)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(janitor)
library(tibble)
library(stringr)
library(shiny)
library(ggpubr)


politician_dbq <- dbConnect(RSQLite::SQLite(), "zh_politicians.db")
# db_list_tables(politician_dbq)
# dbDisconnect(politician_dbq)                # use if disconnect

persons <- tbl(politician_dbq, "PERSONS")
persons_tbl <- as_tibble(persons)
  persons_tbl <- persons_tbl %>% 
    mutate(as.numeric(YEAR_OF_BIRTH,YEAR_OF_DEATH)) %>%
      rename(PERSON_ID = ID)

mandates <- tbl(politician_dbq, "MANDATES")      # FUNKTIONIERT
mandates_tbl <- as_tibble(mandates)
mandates_tbl <- mandates_tbl %>% 
mutate(as.numeric(MANDATE_START_DAY, MANDATE_START_MONTH, MANDATE_START_YEAR, MANDATE_END_DAY, MANDATE_END_MONTH, MANDATE_END_YEAR))


addresses <- tbl(politician_dbq, "ADDRESSES")
addresses_tbl <- as_tibble(addresses)
addresses_tbl <- addresses_tbl %>% 
 mutate(as.numeric(MANDATE_START_DAY, MANDATE_START_MONTH, MANDATE_START_YEAR, MANDATE_END_DAY, MANDATE_END_MONTH, MANDATE_END_YEAR))


affiliations <- tbl(politician_dbq, "AFFILIATIONS")
affiliations_tbl <- as_tibble(affiliations)
affiliations_tbl <- affiliations_tbl %>% 
mutate(as.numeric(AFFILIATION_START_DAY, AFFILIATION_START_MONTH, AFFILIATION_START_YEAR, AFFILIATION_END_MONTH, AFFILIATION_END_YEAR))
       
mand_addr <- full_join(mandates_tbl, addresses_tbl, by = "PERSON_ID", copy = true) %>% 
clean_names()
mand_addr2 <- full_join(affiliations_tbl, persons_tbl, by = "PERSON_ID", copy = TRUE) %>% 
  clean_names()

# Funktioniert
mand_addr3 <- full_join(mand_addr, mand_addr2, by = "person_id", copy = TRUE)

#########################

# Funktioniert !!
age_try <- mand_addr3 %>% 
  select(assembly,gender,mandate_start_year_x,mandate_end_year_x, year_of_birth, year_of_death) %>%
  filter(year_of_birth != "", year_of_death != "") %>% 
      filter(year_of_birth != year_of_death) %>% 
        filter(gender !="") %>% 
          mutate(year_of_birth = as.numeric(year_of_birth)) %>% 
            mutate(year_of_death = as.numeric(year_of_death)) %>% 
              mutate(age = (year_of_death - year_of_birth)) %>% 
                filter(age >=20 & age <=70) %>%  
                  group_by(assembly) %>% 
                    arrange(desc(mandate_start_year_x))
                      
  
gender_man_count <- age_try %>% 
  select(assembly,gender, mandate_start_year_x, mandate_end_year_x) %>% 
    # mutate(count) %>% 
      count(assembly, gender, mandate_start_year_x, mandate_end_year_x,)
        
ggplot(data=gender_man_count, mapping = aes(x=assembly,y=n))+
   geom_line()+
  geom_point(size=0.5, aes(color=assembly))+
    facet_grid(vars(assembly, gender))+
    labs(x="Spread over time", y="Number ob members")
      

count_gen_per_assembly <- age_try %>% 
  select(assembly,gender) %>% 
    group_by(assembly) %>% 
      count(gender, assembly)
    
# Plot    # Funktioniert

bp <- ggplot(data=count_gen_per_assembly, mapping = aes(x=assembly, y=n))+
  geom_point()+
  geom_point(size=4, aes(color=assembly))+
    facet_grid(vars(assembly, gender,n))+
    labs(x="Counil", y="Spread over time")+
      coord_flip()
   
  dp <- ggplot(data=gender_man_count, mapping = aes(x=mandate_start_year_x,y=n))+
   geom_line()+
  geom_line(size=0.5, aes(color=assembly))+
    facet_grid(vars(assembly, gender))+
    labs(x="Spread over time", y="Number of members")


  ggarrange(dp, bp + rremove("x.text"), 
          labels = c("A", "B"),
          ncol = 1, nrow = 2)

# Done

``` 

Part 3
Create a new plot showing the proportion of elected politicians from each party in year 2000. You want to show this by assembly, so use one facet with one pie chart per assembly. Also show your result in a table.

If you don't know how to do a pie chart, try to search on the Internet how to do pie charts with {ggplot2}. I will happily give you some links if you cannot find any, but one of the goal of this course is that you feel confident enough to find your own resources on the internet.

There are several ways to create nice-looking tables in R notebook. Have a look at the "Table Suggestions" part in the cheatsheet and choose your favorite.

```{r}




```

Part 4
Have another look at the composition of the assemblies: this time use a line chart to show how it changed over the years.

```{r}


```

Part 5
For the politicians that have a YEAR_OF_DEATH in the data, find the average life span. Does it change if you go by a TITLE? Use a plot to show the difference (or its absence).

```{r}


```


Part 6
Which politicians have had the most mandates? Create a top 10 horizontal bar chart.

```{r}


```


Part 7
Do some politicians have multiple mandates at the same time?

```{r}


```



Part 8
Have some politicians been affiliated to different parties over the years?

```{r}


```


Part 9
Take a sample of 20 politicians with a listed address and plot them on a {leaflet} map. You will need to use an API that converts the addresses to geocoordinates.

```{r}



```


